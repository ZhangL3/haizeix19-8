# 操作系统与系统编程

## 文件与目录操作

### 相关命令实现

#### 使用 getopt 解析命令行参数

- 参数(arguments)和选项(option)的区别
	- ls -a /etc
		- -a 选项
			- a 选项字符 (option character)
		- /etc 参数
- man 3 getopt

```
// 参数和 main 函数相同
int getopt(int argc, char * const argv[],
				const char *optstring);

// 全局变量
extern char *optarg;
extern int optind, opterr, optopt;

// example

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
	int flags, opt;
	int nsecs, tfnd;

	nsecs = 0;
	tfnd = 0;
	flags = 0;

	// optstring: "nt:", n 选项没有选项参数, t 选项有选项参数
	while ((opt = getopt(argc, argv, "nt:")) != -1) {
		// optind shows the index of next element to be processed in argv array
		switch (opt) {
		case 'n':
			flags = 1;
			break;
		case 't':
			// atoi: 字符串专成整形
			nsecs = atoi(optarg);
			tfnd = 1;
			break;
		default: /* '?' */
			// fprintf: 打印到一个文件 (stderr)
			fprintf(stderr, "Usage: %s [-t nsecs] [-n] name\n",
					// argv[0]: 程序自己
					argv[0]);
			// 宏定义，错误推出状态
			exit(EXIT_FAILURE);
		}
	}

	printf("flags=%d; tfnd=%d; nsecs=%d; optind=%d\n",
			flags, tfnd, nsecs, optind);

	// 索引值大于参数数量，就是没跟参数
	if (optind >= argc) {
		fprintf(stderr, "Expected argument after options\n");
		exit(EXIT_FAILURE);
	}

	// 如果 getopt() 返回了-1,表示目前没有更多的选项可解析了,且 optind 的值比argc要小,那么 argv[optind]就表示命令行中下一个非选项单词
	printf("name argument = %s\n", argv[optind]);

	/* Other code omitted */

	exit(EXIT_SUCCESS);
}
```

#### ls 命令的实现 (ls.c)

- 处理选项
	- getopt()
- 处理参数
	- ls .
	- ls /etc
		- do_ls in 04linuxOS/ls.c
	- ls a.log
		- If "opendir: Not a directory", echo the name of file

#### more 命令的实现 (more.c)

- 实现 more 需要的函数
	- fopen
		- stream open functions (打开文件流)
	- fread
		- 把流吸入到一个 buffer 中，比如 string
	- fgets
		- 一行一行的把流写入 buffer 中
	- fputs
		- 把 string 写入流中
	- fclose

#### more 命令的实现 (cp.c)

- file descriptor 文件描述符
	- fopen 返回 file stream，还有另外一种打开文件的返回方式 open 返回 file descriptor 文件描述符
	- 
- 实现 cp 需要的函数
	- open
		- 可以打开文件也可以新建文嘉
	- create
		- 可以被 open 代替
	- ssize_t read(int fd, const void *buf, size_t count);
		- 从 fd 顺序读出并存入 buf 中，最长读 count 个字节
	- ssize_t write(int fd, const void *buf, size_t count);
		- 从 buf 读出并存入 fd 中, 最长 count 个字节
	- strlen
	- close
	- sizeof

## 阻塞 IO 与 非阻塞 IO

视频不完整，用 研发工程师 操作系统编程 第4章 高级IO1 作为补充

- 阻塞 (进程)
	- 三态模型 (进程的状态)
		- ready
		- block
		- running
	- CPU 分时间片启动 ready 的进程，进入 running
	- running 是遇到资源等待会进入 block
	- IO 结束后进入 ready，等待 CPU 继续执行
	- block vs 挂起 (sleeping)
		- block
			- 进程状态：等待进程需要的资源, 数据
		- sleeping
			- 进程调度：原先执行，现在不执行，把它的状态保存下来
	- 阻塞类型
		- IO 阻塞
		- 进程阻塞
		- 函数阻塞
			- recv，连接上了，在等发送
			- accept, 等待接收 syn 报文 (在函数上的阻塞也算是 IO 阻塞)

- 阻塞 IO VS 非阻塞 IO
	- 非阻塞
		- 同步
			- 不等，但要一直问是否完成
		- 异步 IO
			- 回调函数
	- IO 默认是阻塞的
		- 设置 IO 方式
- 非阻塞 IO 的实现与演示
  - ioctl 函数 control device (file)
    - int ioctl(fd, int FIONBIO, *) // (fiel descriptor, nonblock IO, unsigned long pointer)
  - fcntl 函数 manipulate file descriptor
    - int fcntl(int fd, int cmd)
- select / pselect
	- 监控多个文件描述符，看他是否就绪
	- pselect
		- 可以通过定义 sigmask 忽略别的信号

## 缓冲 IO

- 三种机制
	- nonbuffered
	- block buffered 块缓冲（全缓冲）
		- block vs inodes
			- All Unix filesystems use two basic components to organize and store data: blocks and inodes.
			- Just as a physical disk is organized into sectors, data on a filesystem is abstracted into blocks. Blocks have a fixed size, determined at the time the filesystem is created. The block size of a filesystem determines how many bytes are allocated to each block on the filesystem. Generally, block sizes are 1 KB, 2 KB, or 4 KB for 32-bit systems. A block size of 8 KB is also available on 64-bit systems.
			- Inodes are used to map blocks to physical disk locations on Unix filesystems. Every file created, whether it’s a directory, normal file, or special file, is assigned an inode. Inodes work in much the same way as pointers do in programming languages such as C, Perl, and Java. Inodes also store information about a file, including its type, size, and parent directory. On traditional Unix filesystems, inodes are typically allocated when the filesystem is created. ext2, for example, allocates one inode for every 8 KB worth of data blocks when a new filesystem is initialized, although this value can be manually altered. That means an ext2 filesystem with a block size of 4 KB allocates a single inode for every two data blocks.
		- block
			- 文件 IO 中的基本单位
			- 常见块大小 (byte)
				- 512， 1024, 2048, 4096
	- line buffered
		- 换行就清空