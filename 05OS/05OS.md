# 操作系统与系统编程

## 文件与目录操作

### 相关命令实现

#### 使用 getopt 解析命令行参数

- 参数(arguments)和选项(option)的区别
	- ls -a /etc
		- -a 选项
			- a 选项字符 (option character)
		- /etc 参数
- man 3 getopt

```
// 参数和 main 函数相同
int getopt(int argc, char * const argv[],
				const char *optstring);

// 全局变量
extern char *optarg;
extern int optind, opterr, optopt;

// example

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
	int flags, opt;
	int nsecs, tfnd;

	nsecs = 0;
	tfnd = 0;
	flags = 0;

	// optstring: "nt:", n 选项没有选项参数, t 选项有选项参数
	while ((opt = getopt(argc, argv, "nt:")) != -1) {
		// optind shows the index of next element to be processed in argv array
		switch (opt) {
		case 'n':
			flags = 1;
			break;
		case 't':
			// atoi: 字符串专成整形
			nsecs = atoi(optarg);
			tfnd = 1;
			break;
		default: /* '?' */
			// fprintf: 打印到一个文件 (stderr)
			fprintf(stderr, "Usage: %s [-t nsecs] [-n] name\n",
					// argv[0]: 程序自己
					argv[0]);
			// 宏定义，错误推出状态
			exit(EXIT_FAILURE);
		}
	}

	printf("flags=%d; tfnd=%d; nsecs=%d; optind=%d\n",
			flags, tfnd, nsecs, optind);

	// 索引值大于参数数量，就是没跟参数
	if (optind >= argc) {
		fprintf(stderr, "Expected argument after options\n");
		exit(EXIT_FAILURE);
	}

	// 如果 getopt() 返回了-1,表示目前没有更多的选项可解析了,且 optind 的值比argc要小,那么 argv[optind]就表示命令行中下一个非选项单词
	printf("name argument = %s\n", argv[optind]);

	/* Other code omitted */

	exit(EXIT_SUCCESS);
}
```

#### ls 命令的实现 (ls.c)

- 处理选项
	- getopt()
- 处理参数
	- ls .
	- ls /etc
		- do_ls in 04linuxOS/ls.c
	- ls a.log
		- If "opendir: Not a directory", echo the name of file

#### more 命令的实现 (more.c)

- 实现 more 需要的函数
	- fopen
		- stream open functions (打开文件流)
	- fread
		- 把流吸入到一个 buffer 中，比如 string
	- fgets
		- 一行一行的把流写入 buffer 中
	- fputs
		- 把 string 写入流中
	- fclose

#### more 命令的实现 (cp.c)

- file descriptor 文件描述符
	- fopen 返回 file stream，还有另外一种打开文件的返回方式 open 返回 file descriptor 文件描述符
	- 
- 实现 cp 需要的函数
	- open
		- 可以打开文件也可以新建文嘉
	- create
		- 可以被 open 代替
	- ssize_t read(int fd, const void *buf, size_t count);
		- 从 fd 顺序读出并存入 buf 中，最长读 count 个字节
	- ssize_t write(int fd, const void *buf, size_t count);
		- 从 buf 读出并存入 fd 中, 最长 count 个字节
	- strlen
	- close
	- sizeof